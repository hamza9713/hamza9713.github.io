<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hate Speech Galaxy | 3D Semantic Analysis</title>
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #1a1f2e;
            --card-bg: rgba(25, 30, 45, 0.9);
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --accent-glow: #d2e1e2;
            
            /* Enhanced color scheme */
            --hate-color: #ff3860;
            --hate-glow: #ff3860aa;
            --offensive-color: #e1b918;
            --offensive-glow: #ffdd57aa;
            --neither-color: #23d160;
            --neither-glow: #23d160aa;
            
            --font-mono: 'Courier New', monospace;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-sans);
            overflow: hidden;
            height: 100vh;
        }
        
        .title-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 2rem;
            text-align: center;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(10, 14, 23, 0.95) 0%, transparent 100%);
            pointer-events: none;
        }
        
        .main-title {
            font-size: clamp(2.5rem, 8vw, 5.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 32px;
            background: linear-gradient(135deg, 
                #ffffff 0%, 
                #e0e0e0 20%,
                #c0c0c0 40%, 
                #a0a0a0 60%,
                #909090 80%,
                #606060 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -2px;
        }
        
        .subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            letter-spacing: 0.3rem;
            text-transform: uppercase;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* EXIT BUTTON */
        .exit-button {
            position: fixed;
            top: 1.5rem;
            left: 1.5rem;
            background: rgba(25, 30, 45, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            padding: 0.8rem 1.5rem;
            border-radius: 12px;
            font-size: 0.9rem;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            text-decoration: none;
            font-weight: 500;
        }
        
        .exit-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .exit-button:active {
            transform: translateY(0);
        }
        
        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 450px;
            height: 100vh;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 200;
            overflow-y: auto;
            box-shadow: -20px 0 50px rgba(0, 0, 0, 0.5);
        }
        
        .side-panel.active {
            transform: translateX(0);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-title {
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(135deg, #00f3ff 0%, #b86bff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .close-panel {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .close-panel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .text-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .text-content {
            line-height: 1.6;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* MOBILE TOOLTIP - FIXED */
        .mobile-tooltip {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1.2rem;
            color: var(--text-primary);
            max-width: 90vw;
            width: 400px;
            z-index: 300;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
        }
        
        .mobile-tooltip.active {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            display: block;
        }
        
        .mobile-tooltip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .mobile-tooltip-category {
            display: inline-flex;
            align-items: center;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .mobile-tooltip-hate { background: rgba(255, 56, 96, 0.2); color: #ff3860; }
        .mobile-tooltip-offensive { background: rgba(255, 221, 87, 0.2); color: #ffdd57; }
        .mobile-tooltip-neither { background: rgba(35, 209, 96, 0.2); color: #23d160; }
        
        .mobile-tooltip-text {
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .mobile-tooltip-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.2rem;
            line-height: 1;
        }
        
        /* Word Cloud Styles */
        .word-cloud-container {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .word-cloud-title {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
        }
        
        .word-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .word-cloud-item {
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            transform: scale(1);
        }
        
        .word-cloud-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .word-cloud-item.hate {
            background: rgba(255, 56, 96, 0.2);
            color: #ff3860;
            border: 1px solid rgba(255, 56, 96, 0.3);
        }
        
        .word-cloud-item.offensive {
            background: rgba(255, 221, 87, 0.2);
            color: #e9c535;
            border: 1px solid rgba(255, 221, 87, 0.3);
        }
        
        .word-cloud-item.neither {
            background: rgba(35, 209, 96, 0.2);
            color: #23d160;
            border: 1px solid rgba(35, 209, 96, 0.3);
        }
        
        .word-cloud-item.mixed {
            background: linear-gradient(45deg, 
                rgba(255, 56, 96, 0.2), 
                rgba(255, 221, 87, 0.2),
                rgba(35, 209, 96, 0.2));
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .word-tooltip {
            position: fixed;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            max-width: 250px;
            z-index: 1000;
            display: none;
            font-size: 0.8rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .word-tooltip .word {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 0.3rem;
        }
        
        .word-tooltip .distribution {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.3rem;
            margin: 0.3rem 0;
        }
        
        .dist-item {
            text-align: center;
            padding: 0.3rem;
            border-radius: 4px;
            font-size: 0.7rem;
        }
        
        .dist-item.hate { background: rgba(255, 56, 96, 0.2); }
        .dist-item.offensive { background: rgba(255, 221, 87, 0.2); }
        .dist-item.neither { background: rgba(35, 209, 96, 0.2); }
        
        .word-tooltip .example {
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 0.5rem;
            font-size: 0.75rem;
        }
        
        .probability-meter {
            margin: 1rem 0;
        }
        
        .probability-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .meter-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3860, #ffdd57);
            border-radius: 4px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            font-family: var(--font-mono);
            margin-bottom: 0.5rem;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1rem;
        }
        
        .category-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0.5rem 0;
        }
        
        .tag-hate { background: rgba(255, 56, 96, 0.2); color: #ff3860; border: 1px solid rgba(255, 56, 96, 0.3); }
        .tag-offensive { background: rgba(255, 221, 87, 0.2); color: #ffdd57; border: 1px solid rgba(255, 221, 87, 0.3); }
        .tag-neither { background: rgba(35, 209, 96, 0.2); color: #23d160; border: 1px solid rgba(35, 209, 96, 0.3); }
        
        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s ease;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            position: relative;
            margin-bottom: 2rem;
        }
        
        .spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-top: 3px solid var(--accent-glow);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            filter: drop-shadow(0 0 10px var(--accent-glow));
        }
        
        .spinner-ring:nth-child(2) {
            border-top-color: #b86bff;
            animation-delay: 0.2s;
        }
        
        .spinner-ring:nth-child(3) {
            border-top-color: #ff3860;
            animation-delay: 0.4s;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-progress {
            margin-top: 1rem;
            font-family: var(--font-mono);
            color: var(--text-secondary);
        }
        
        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(25, 30, 45, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 100px;
            padding: 1rem 2rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
            white-space: nowrap;
        }
        
        /* Touch overlay for mobile to close tooltip */
        .tooltip-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 299;
            display: none;
        }
        
        .tooltip-overlay.active {
            display: block;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .side-panel {
                width: 100%;
                padding: 1rem;
            }
            
            .main-title {
                font-size: 2rem;
                margin-bottom: 20px;
            }
            
            .instructions {
                display: none;
            }
            
            .exit-button {
                top: 1rem;
                left: 1rem;
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
            }
            
            .mobile-tooltip {
                width: 85vw;
                padding: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.8rem;
            }
            
            .stat-card {
                padding: 0.8rem;
            }
            
            .stat-value {
                font-size: 1.5rem;
            }
        }
        
        @media (max-width: 480px) {
            .main-title {
                font-size: 1.8rem;
            }
            
            .exit-button {
                top: 0.8rem;
                left: 0.8rem;
                padding: 0.5rem 0.8rem;
                font-size: 0.75rem;
            }
            
            .mobile-tooltip {
                width: 90vw;
                bottom: 15px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.6rem;
            }
            
            .stat-card {
                padding: 0.6rem;
            }
            
            .stat-value {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <!-- EXIT BUTTON -->
    <a href="javascript:history.back()" class="exit-button">
        ← Back to Projects
    </a>

    <div class="title-container">
        <div class="main-title">HATE SPEECH CLOUD</div>
    </div>

    <!-- Loading screen hidden by default -->
    <div id="loading-screen">
        <div class="loading-spinner">
            <div class="spinner-ring"></div>
            <div class="spinner-ring"></div>
            <div class="spinner-ring"></div>
        </div>
        <div class="loading-progress" id="loading-progress">Loading dataset...</div>
    </div>

    <div id="canvas-container"></div>

    <!-- MOBILE TOOLTIP -->
    <div class="mobile-tooltip" id="mobile-tooltip">
        <button class="mobile-tooltip-close" id="mobile-tooltip-close">×</button>
        <div class="mobile-tooltip-header">
            <div class="mobile-tooltip-category" id="mobile-category">Category</div>
            <div id="mobile-confidence">100%</div>
        </div>
        <div class="mobile-tooltip-text" id="mobile-text">
            <!-- Text will be inserted here -->
        </div>
        <div class="stats-grid" id="mobile-stats">
            <!-- Stats will be inserted here -->
        </div>
    </div>
    
    <!-- Touch overlay to close mobile tooltip -->
    <div class="tooltip-overlay" id="tooltip-overlay"></div>

    <!-- Side Panel for Details -->
    <div class="side-panel" id="side-panel">
        <div class="panel-header">
            <h2 class="panel-title">Analysis Details</h2>
            <button class="close-panel" id="close-panel">×</button>
        </div>
        
        <div class="category-tag" id="category-tag"></div>
        
        <div class="text-display">
            <div class="text-content" id="text-content">
                <!-- Text will be inserted here -->
            </div>
            
            <div class="probability-meter">
                <div class="probability-label">
                    <span>Model Confidence</span>
                    <span id="confidence-value">0%</span>
                </div>
                <div class="meter-bar">
                    <div class="meter-fill" id="confidence-bar"></div>
                </div>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="stat-entropy">0.00</div>
                <div class="stat-label">Entropy</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-ambiguity">Low</div>
                <div class="stat-label">Ambiguity</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-targets">0</div>
                <div class="stat-label">Target Groups</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-toxic-words">0</div>
                <div class="stat-label">Toxic Words</div>
            </div>
        </div>
        
        <!-- Word Cloud Section -->
        <div class="word-cloud-container">
            <div class="word-cloud-title">Top Predictive Words</div>
            <div class="word-cloud" id="word-cloud">
                <!-- Word cloud will be generated here -->
            </div>
        </div>
        
        <div id="analysis-insights"></div>
    </div>

    <div class="instructions">
        Click/Tap points for details • Drag to rotate • Scroll to zoom • WASD to navigate • R to reset view
    </div>

    <!-- Word Tooltip -->
    <div class="word-tooltip" id="word-tooltip"></div>

    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
    class HateSpeechGalaxy {
        constructor() {
            this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
            this.container = document.getElementById('canvas-container');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            
            // OPTIMIZED: Use performance-optimized renderer settings
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            
            this.controls = null;
            
            this.data = [];
            this.filteredData = [];
            this.wordData = [];
            this.points = [];
            this.wordParticles = [];
            this.selectedPoint = null;
            this.flowSpeed = 0.5;
            
            // Color mapping
            this.colors = {
                'hate_speech': {
                    main: 0xff3860,
                    glow: 0xff3860,
                    intensity: 2.0
                },
                'offensive': {
                    main: 0xffdd57,
                    glow: 0xffdd57,
                    intensity: 1.5
                },
                'neither': {
                    main: 0x23d160,
                    glow: 0x23d160,
                    intensity: 1.0
                }
            };
            
            this.init();
        }
        
        async init() {
            try {
                this.setupRenderer();
                this.setupLights();
                this.setupControls();
                
                // Load data in parallel for faster initialization
                await Promise.all([
                    this.loadWordData(),
                    this.loadData()
                ]);
                
                this.createGalaxy();
                this.createWordCloud3D();
                this.setupEventListeners();
                this.setupWordHover();
                this.setupMobileTooltip();
                this.animate();
                
                // Hide loading screen if it somehow got shown
                this.hideLoadingScreen();
            } catch (error) {
                console.error('Initialization error:', error);
                this.showError(error.message);
            }
        }
        
        setupRenderer() {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            this.renderer.setClearColor(0x0a0e17, 1);
            this.renderer.shadowMap.enabled = false;
            this.container.appendChild(this.renderer.domElement);
            
            this.camera.position.set(0, 30, 50);
            this.camera.lookAt(0, 0, 0);
        }
        
        setupLights() {
            // Optimized lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            this.scene.add(ambient);
            
            const directional = new THREE.DirectionalLight(0xffffff, 0.7);
            directional.position.set(50, 100, 50);
            this.scene.add(directional);
            
            // Reduced intensity for point lights
            const hateLight = new THREE.PointLight(0xff3860, 3, 50);
            hateLight.position.set(-20, 0, 0);
            this.scene.add(hateLight);
            
            const offensiveLight = new THREE.PointLight(0xffdd57, 3, 50);
            offensiveLight.position.set(0, 0, -20);
            this.scene.add(offensiveLight);
            
            const neitherLight = new THREE.PointLight(0x23d160, 3, 50);
            neitherLight.position.set(20, 0, 0);
            this.scene.add(neitherLight);
        }
        
        setupControls() {
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.08;
            this.controls.rotateSpeed = 0.1;
            this.controls.zoomSpeed = 1.0;
            this.controls.minDistance = 10;
            this.controls.maxDistance = 200;
            this.controls.maxPolarAngle = Math.PI;
        }
        
        async loadWordData() {
            try {
                // Use cache-busting for development
                const cacheBuster = '?v=' + Date.now();
                const response = await fetch('data/hate_speech_3d_words.json' + cacheBuster);
                if (!response.ok) throw new Error(`Failed to load word data: ${response.status}`);
                
                const wordData = await response.json();
                this.wordData = wordData.words || [];
                
                // Create word cloud in UI
                this.createWordCloudUI();
                
            } catch (error) {
                console.log('Using sample word data:', error.message);
                await this.generateSampleWordData();
            }
        }
        
        createWordCloudUI() {
            const wordCloud = document.getElementById('word-cloud');
            wordCloud.innerHTML = '';
            
            // Sort words by weight and take top 40
            const topWords = [...this.wordData]
                .sort((a, b) => b.weight - a.weight)
                .slice(0, 40);
            
            topWords.forEach(wordData => {
                const item = document.createElement('div');
                item.className = 'word-cloud-item';
                
                // Determine dominant category
                const distribution = wordData.class_distribution || {};
                let maxKey = '';
                let maxValue = 0;
                for (const key in distribution) {
                    if (distribution[key] > maxValue) {
                        maxValue = distribution[key];
                        maxKey = key;
                    }
                }
                
                // Map to CSS classes
                let categoryClass = 'mixed';
                if (maxKey.includes('hate')) categoryClass = 'hate';
                else if (maxKey.includes('offensive')) categoryClass = 'offensive';
                else if (maxKey.includes('neither')) categoryClass = 'neither';
                
                item.classList.add(categoryClass);
                item.textContent = wordData.text;
                item.title = `Click for details (Weight: ${wordData.weight})`;
                
                // Store data for tooltip
                item.dataset.word = wordData.text;
                item.dataset.weight = wordData.weight;
                item.dataset.distribution = JSON.stringify(distribution);
                item.dataset.examples = JSON.stringify(wordData.examples || []);
                
                wordCloud.appendChild(item);
            });
        }
        
        setupWordHover() {
            const wordCloud = document.getElementById('word-cloud');
            const tooltip = document.getElementById('word-tooltip');
            
            let hoverTimeout;
            let lastHoveredItem = null;
            
            wordCloud.addEventListener('mouseover', (e) => {
                const item = e.target.closest('.word-cloud-item');
                if (!item) return;
                
                lastHoveredItem = item;
                
                hoverTimeout = setTimeout(() => {
                    const word = item.dataset.word;
                    const weight = item.dataset.weight;
                    const distribution = JSON.parse(item.dataset.distribution);
                    const examples = JSON.parse(item.dataset.examples);
                    
                    // Calculate percentages
                    let total = 0;
                    for (const key in distribution) {
                        total += distribution[key];
                    }
                    
                    // Create distribution display
                    let distHTML = '';
                    for (const key in distribution) {
                        const percent = ((distribution[key] / total) * 100).toFixed(1);
                        let category = key.replace('_', ' ');
                        let distClass = 'mixed';
                        if (key.includes('hate')) distClass = 'hate';
                        else if (key.includes('offensive')) distClass = 'offensive';
                        else if (key.includes('neither')) distClass = 'neither';
                        
                        distHTML += `
                            <div class="dist-item ${distClass}">
                                <div style="font-weight: bold;">${category}</div>
                                <div>${percent}% (${distribution[key]})</div>
                            </div>
                        `;
                    }
                    
                    // Get an example
                    const example = examples && examples.length > 0 ? 
                        examples[0].substring(0, 80) + (examples[0].length > 80 ? '...' : '') : 
                        'No example available';
                    
                    tooltip.innerHTML = `
                        <div class="word">${word}</div>
                        <div style="color: var(--text-secondary); font-size: 0.7rem;">
                            Total occurrences: ${weight}
                        </div>
                        <div class="distribution">${distHTML}</div>
                        <div class="example">"${example}"</div>
                    `;
                    
                    // Position tooltip near cursor
                    const rect = item.getBoundingClientRect();
                    const x = e.clientX;
                    const y = e.clientY;
                    
                    // Position tooltip to avoid covering the word
                    let left = x + 15;
                    let top = y + 15;
                    
                    // Keep tooltip within viewport
                    if (left + tooltip.offsetWidth > window.innerWidth) {
                        left = x - tooltip.offsetWidth - 5;
                    }
                    if (top + tooltip.offsetHeight > window.innerHeight) {
                        top = y - tooltip.offsetHeight - 5;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.display = 'block';
                }, 150);
            });
            
            wordCloud.addEventListener('mouseout', (e) => {
                clearTimeout(hoverTimeout);
                
                // Only hide if not moving to tooltip
                const relatedTarget = e.relatedTarget;
                if (!relatedTarget || !relatedTarget.closest('.word-tooltip')) {
                    tooltip.style.display = 'none';
                }
                
                if (lastHoveredItem) {
                    lastHoveredItem = null;
                }
            });
            
            // Hide tooltip when mouse leaves it
            tooltip.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
            
            wordCloud.addEventListener('click', (e) => {
                const item = e.target.closest('.word-cloud-item');
                if (!item) return;
                
                const word = item.dataset.word;
                // Find examples with this word in the main data
                const examples = this.data
                    .filter(d => d.original_text.toLowerCase().includes(word.toLowerCase()))
                    .slice(0, 3);
                
                if (examples.length > 0) {
                    // Create a new side panel view for word analysis
                    this.showWordAnalysis(word, examples);
                }
            });
        }
        
        setupMobileTooltip() {
            const mobileTooltip = document.getElementById('mobile-tooltip');
            const mobileTooltipClose = document.getElementById('mobile-tooltip-close');
            const tooltipOverlay = document.getElementById('tooltip-overlay');
            
            // Close mobile tooltip
            mobileTooltipClose.addEventListener('click', () => {
                this.hideMobileTooltip();
            });
            
            // Close mobile tooltip when tapping overlay
            tooltipOverlay.addEventListener('click', () => {
                this.hideMobileTooltip();
            });
            
            // Close mobile tooltip with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.hideMobileTooltip();
                }
            });
        }
        
        showWordAnalysis(word, examples) {
            const panel = document.getElementById('side-panel');
            const tag = document.getElementById('category-tag');
            const textContent = document.getElementById('text-content');
            
            // Find word data
            const wordData = this.wordData.find(w => w.text === word);
            
            let tagClass = 'tag-hate';
            if (wordData) {
                const distribution = wordData.class_distribution || {};
                let maxKey = '';
                let maxValue = 0;
                for (const key in distribution) {
                    if (distribution[key] > maxValue) {
                        maxValue = distribution[key];
                        maxKey = key;
                    }
                }
                if (maxKey.includes('offensive')) tagClass = 'tag-offensive';
                else if (maxKey.includes('neither')) tagClass = 'tag-neither';
            }
            
            tag.className = `category-tag ${tagClass}`;
            tag.innerHTML = `WORD ANALYSIS: <strong>${word.toUpperCase()}</strong>`;
            
            // Show examples
            let examplesHTML = '<div style="margin-bottom: 1rem;"><strong>Examples in context:</strong></div>';
            examples.forEach((example, i) => {
                let text = example.original_text;
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                text = text.replace(regex, `<span style="background: rgba(255,56,96,0.3); padding: 0.1rem 0.3rem; border-radius: 3px; color: #ff3860;">${word}</span>`);
                examplesHTML += `
                    <div style="margin-bottom: 1rem; padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 6px;">
                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.3rem;">
                            ${example.true_label_name.replace('_', ' ').toUpperCase()}
                        </div>
                        ${text}
                    </div>
                `;
            });
            
            textContent.innerHTML = examplesHTML;
            
            // Show word distribution stats
            const insightsDiv = document.getElementById('analysis-insights');
            if (wordData) {
                const distribution = wordData.class_distribution || {};
                insightsDiv.innerHTML = `
                    <div class="control-title" style="margin-top: 1rem;">Word Distribution Analysis</div>
                    <div style="margin-top: 0.5rem;">
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                            ${Object.entries(distribution).map(([category, count]) => `
                                <div style="flex: 1; text-align: center; padding: 0.5rem; background: ${category.includes('hate') ? 'rgba(255,56,96,0.1)' : category.includes('offensive') ? 'rgba(255,221,87,0.1)' : 'rgba(35,209,96,0.1)'}; border-radius: 8px;">
                                    <div style="font-weight: bold; font-size: 1.2rem;">${count}</div>
                                    <div style="font-size: 0.7rem; color: var(--text-secondary);">${category.replace('_', ' ')}</div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">
                            This word appears <strong>${wordData.weight}</strong> times in the dataset
                        </div>
                    </div>
                `;
            }
            
            panel.classList.add('active');
        }
        
        async generateSampleWordData() {
            // Generate sample word data if real data isn't available
            this.wordData = [
                {
                    text: "bitch",
                    weight: 7780,
                    class_distribution: {
                        "offensive_language": 7583,
                        "neither": 10,
                        "hate_speech": 187
                    },
                    examples: ["RT @UrKindOfBrand Dawg!!!! RT @80sbaby4life: You ever fuck a bitch and she start to cry?"]
                },
                {
                    text: "like",
                    weight: 2541,
                    class_distribution: {
                        "offensive_language": 2103,
                        "neither": 283,
                        "hate_speech": 155
                    },
                    examples: ["RT @C_G_Anderson: @viva_based she look like a tranny"]
                },
                {
                    text: "hoes",
                    weight: 2223,
                    class_distribution: {
                        "offensive_language": 2161,
                        "neither": 12,
                        "hate_speech": 50
                    },
                    examples: ["The shit just blows me..claim you so faithful but still fucking with hoes!"]
                }
            ];
            
            this.createWordCloudUI();
        }
        
        async loadData() {
            try {
                // Use cache-busting for development
                const cacheBuster = '?v=' + Date.now();
                const response = await fetch('HS_analysis_3d.json' + cacheBuster);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const rawData = await response.json();
                this.processData(rawData);
                
            } catch (error) {
                console.log('Using synthetic data:', error.message);
                await this.generateSyntheticData();
            }
        }
        
        processData(rawData) {
            // OPTIMIZED: Reduced data points for faster loading
            const dataLimit = 3000;
            this.data = rawData.slice(0, dataLimit).map((item, index) => {
                const angle = (index / dataLimit) * Math.PI * 2;
                const radius = 15 + Math.random() * 25;
                const height = (Math.random() - 0.5) * 30;
                
                const position = [
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                ];
                
                return {
                    id: index,
                    original_text: item.text || item.original_text || this.generateSampleText(index),
                    true_label_name: String(item.true_label_name || 'neither').toLowerCase(),
                    predicted_label_name: String(item.predicted_label_name || 'neither').toLowerCase(),
                    confidence: parseFloat(item.confidence) || 0.5 + Math.random() * 0.5,
                    entropy: parseFloat(item.entropy) || Math.random(),
                    position_3d: position,
                    toxic_words: this.extractToxicWords(item.text || item.original_text || ''),
                    is_misclassified: item.true_label_name !== item.predicted_label_name,
                    semantic_properties: {
                        offensiveness: Math.random(),
                        targetSpecificity: Math.random(),
                        intensity: Math.random()
                    }
                };
            });
            
            this.filteredData = this.data;
        }
        
        extractToxicWords(text) {
            if (!this.wordData || this.wordData.length === 0) return [];
            
            const words = text.toLowerCase().split(/\W+/);
            return words.filter(word => 
                this.wordData.some(wd => wd.text.toLowerCase() === word)
            );
        }
        
        generateSampleText(index) {
            const samples = [
                "I can't believe how stupid some people are with their ridiculous opinions.",
                "This is absolutely unacceptable behavior that needs to be addressed immediately.",
                "Why do we tolerate such nonsense from these ignorant individuals?",
                "I support everyone's right to express themselves freely and respectfully.",
                "This kind of language has no place in civilized society.",
                "We need more understanding and less judgment in our conversations.",
                "The hate being spread online is truly disturbing and harmful.",
                "Let's focus on building bridges instead of walls between people.",
                "Some comments cross the line from criticism to outright abuse.",
                "We should strive for respectful dialogue even when we disagree."
            ];
            return samples[index % samples.length];
        }
        
        async generateSyntheticData() {
            console.log('Generating synthetic hate speech analysis data...');
            
            this.data = [];
            const count = 3000;
            
            for (let i = 0; i < count; i++) {
                const label = Math.random() < 0.05 ? 'hate_speech' : 
                             Math.random() < 0.7 ? 'offensive' : 'neither';
                
                const predicted = Math.random() < 0.85 ? label : 
                                 ['hate_speech', 'offensive', 'neither'].find(l => l !== label);
                
                const angle = (i / count) * Math.PI * 2;
                const radius = 15 + Math.random() * 25;
                const height = (Math.random() - 0.5) * 30;
                
                this.data.push({
                    id: i,
                    original_text: this.generateSampleText(i),
                    true_label_name: label,
                    predicted_label_name: predicted,
                    confidence: 0.6 + Math.random() * 0.4,
                    entropy: Math.random(),
                    position_3d: [
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    ],
                    toxic_words: Math.random() < 0.3 ? 
                        this.wordData.length > 0 ? 
                            [this.wordData[Math.floor(Math.random() * this.wordData.length)].text] : 
                            ['bitch'] : [],
                    is_misclassified: label !== predicted,
                    semantic_properties: {
                        offensiveness: label === 'hate_speech' ? 0.8 + Math.random() * 0.2 :
                                      label === 'offensive' ? 0.4 + Math.random() * 0.4 : 0.1 + Math.random() * 0.3,
                        targetSpecificity: Math.random(),
                        intensity: Math.random()
                    }
                });
            }
            
            this.filteredData = this.data;
        }
        
        createGalaxy() {
            this.clearPoints();
            
            // OPTIMIZED: Use simpler geometry
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            
            this.data.forEach((item, index) => {
                const [x, y, z] = item.position_3d;
                const colorInfo = this.colors[item.true_label_name] || this.colors.neither;
                
                const material = new THREE.MeshPhongMaterial({
                    color: colorInfo.main,
                    emissive: colorInfo.glow,
                    emissiveIntensity: 0.3 * colorInfo.intensity,
                    shininess: 50,
                    transparent: true,
                    opacity: 0.9
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                
                // OPTIMIZED: Use cheaper point lights
                const pointLight = new THREE.PointLight(colorInfo.glow, 0.3, 8);
                pointLight.position.copy(sphere.position);
                
                sphere.userData = {
                    type: 'dataPoint',
                    data: item,
                    index: index
                };
                
                this.scene.add(sphere);
                this.scene.add(pointLight);
                this.points.push({ sphere, light: pointLight });
            });
        }
        
        createWordCloud3D() {
            // Clear existing word particles
            this.wordParticles.forEach(particle => {
                this.scene.remove(particle);
            });
            this.wordParticles = [];
            
            // OPTIMIZED: Reduced number of word particles
            const topWords = this.wordData.slice(0, 2000);
            
            topWords.forEach((wordData, i) => {
                // Determine color based on dominant category
                const distribution = wordData.class_distribution || {};
                let maxKey = '';
                let maxValue = 0;
                for (const key in distribution) {
                    if (distribution[key] > maxValue) {
                        maxValue = distribution[key];
                        maxKey = key;
                    }
                }
                
                let color = 0x666666; // Default gray
                if (maxKey.includes('hate')) color = 0xff3860;
                else if (maxKey.includes('offensive')) color = 0xffdd57;
                else if (maxKey.includes('neither')) color = 0x23d160;
                
                // Create text sprite with reduced size
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                
                // Calculate font size based on weight
                const fontSize = Math.min(20 + (wordData.weight / 100), 30);
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.95)`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(wordData.text.toUpperCase(), 64, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.85
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                // Position in a sphere
                const radius = 60 + (wordData.weight / 100);
                const angle = (i / topWords.length) * Math.PI * 2;
                const height = (Math.random() - 0.5) * 40;
                
                sprite.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                // Scale based on weight (reduced)
                const scale = 2 + (wordData.weight / 3000);
                sprite.scale.set(scale * 3, scale * 1.5, 1);
                
                sprite.userData = {
                    type: 'wordParticle',
                    word: wordData.text,
                    weight: wordData.weight,
                    distribution: distribution,
                    examples: wordData.examples,
                    speed: 0.0005 + (Math.random() * 0.001),
                    radius: radius,
                    angle: angle,
                    height: height,
                    originalHeight: height,
                    originalScaleX: scale * 3,
                    originalScaleY: scale * 1.5
                };
                
                this.scene.add(sprite);
                this.wordParticles.push(sprite);
            });
        }
        
        clearPoints() {
            this.points.forEach(item => {
                this.scene.remove(item.sphere);
                this.scene.remove(item.light);
                item.sphere.geometry.dispose();
                item.sphere.material.dispose();
            });
            this.points = [];
        }
        
        setupEventListeners() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // FIXED: Add proper touch event handling for mobile
            this.setupTouchEvents(raycaster, mouse);
            
            // Click on data points for desktop
            if (!this.isMobile) {
                this.renderer.domElement.addEventListener('click', (event) => {
                    this.handlePointSelection(event, raycaster, mouse);
                });
            }
            
            // Hover effects for data points
            this.renderer.domElement.addEventListener('mousemove', (event) => {
                if (this.isMobile) return;
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObjects(
                    this.points.map(p => p.sphere)
                );
                
                // Reset all points
                this.points.forEach(p => {
                    p.sphere.scale.set(1, 1, 1);
                    p.light.intensity = 0.3;
                });
                
                if (intersects.length > 0) {
                    const point = intersects[0].object;
                    point.scale.set(1.2, 1.2, 1.2);
                    
                    const pointData = this.points.find(p => p.sphere === point);
                    if (pointData) {
                        pointData.light.intensity = 1.0;
                    }
                }
            });
            
            // Hover effects for word particles
            let wordHoverThrottle = false;
            this.renderer.domElement.addEventListener('mousemove', (event) => {
                if (wordHoverThrottle || this.isMobile) return;
                wordHoverThrottle = true;
                
                setTimeout(() => {
                    wordHoverThrottle = false;
                }, 50);
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObjects(this.wordParticles);
                
                // Reset all word particles
                this.wordParticles.forEach(sprite => {
                    sprite.material.opacity = 0.85;
                    sprite.scale.set(
                        sprite.userData.originalScaleX,
                        sprite.userData.originalScaleY,
                        1
                    );
                });
                
                // Highlight hovered word
                if (intersects.length > 0) {
                    const sprite = intersects[0].object;
                    sprite.material.opacity = 0.8;
                    
                    sprite.scale.set(
                        sprite.userData.originalScaleX * 1.3,
                        sprite.userData.originalScaleY * 1.3,
                        1
                    );
                    
                    // Show tooltip for word
                    const tooltip = document.getElementById('word-tooltip');
                    const wordData = sprite.userData;
                    
                    let distHTML = '';
                    for (const key in wordData.distribution) {
                        const percent = ((wordData.distribution[key] / wordData.weight) * 100).toFixed(1);
                        distHTML += `
                            <div style="font-size: 0.7rem; margin: 0.2rem 0;">
                                ${key.replace('_', ' ')}: ${percent}%
                            </div>
                        `;
                    }
                    
                    tooltip.innerHTML = `
                        <div class="word">${wordData.word}</div>
                        <div style="color: var(--text-secondary); font-size: 0.7rem;">
                            Weight: ${wordData.weight}
                        </div>
                        <div style="margin-top: 0.5rem;">${distHTML}</div>
                    `;
                    
                    // Position tooltip near cursor
                    const x = event.clientX;
                    const y = event.clientY;
                    
                    let left = x + 15;
                    let top = y + 15;
                    
                    // Keep tooltip within viewport
                    if (left + tooltip.offsetWidth > window.innerWidth) {
                        left = x - tooltip.offsetWidth - 5;
                    }
                    if (top + tooltip.offsetHeight > window.innerHeight) {
                        top = y - tooltip.offsetHeight - 5;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.display = 'block';
                } else {
                    document.getElementById('word-tooltip').style.display = 'none';
                }
            });
            
            // Hide tooltip when mouse leaves canvas
            this.renderer.domElement.addEventListener('mouseleave', () => {
                document.getElementById('word-tooltip').style.display = 'none';
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                const speed = 2;
                switch(event.key.toLowerCase()) {
                    case 'w':
                        this.camera.position.z -= speed;
                        break;
                    case 's':
                        this.camera.position.z += speed;
                        break;
                    case 'a':
                        this.camera.position.x -= speed;
                        break;
                    case 'd':
                        this.camera.position.x += speed;
                        break;
                    case 'r':
                        this.resetCamera();
                        break;
                    case 'escape':
                        this.hideSidePanel();
                        this.hideMobileTooltip();
                        break;
                }
                this.controls.update();
            });
            
            this.setupUIControls();
        }
        
        setupTouchEvents(raycaster, mouse) {
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            
            this.renderer.domElement.addEventListener('touchstart', (event) => {
                if (!this.isMobile) return;
                
                const touch = event.touches[0];
                touchStartTime = Date.now();
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                // Update mouse for raycasting
                const rect = this.renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                
                event.preventDefault();
            }, { passive: false });
            
            this.renderer.domElement.addEventListener('touchend', (event) => {
                if (!this.isMobile) return;
                
                const touch = event.changedTouches[0];
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                
                // Only process as a tap if it was short and didn't move much
                if (touchDuration < 300 && deltaX < 10 && deltaY < 10) {
                    this.handlePointSelection(event, raycaster, mouse);
                }
                
                event.preventDefault();
            }, { passive: false });
        }
        
        handlePointSelection(event, raycaster, mouse) {
            const rect = this.renderer.domElement.getBoundingClientRect();
            
            if (this.isMobile && event.changedTouches) {
                // Mobile touch
                const touch = event.changedTouches[0];
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            } else {
                // Desktop click
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            }
            
            raycaster.setFromCamera(mouse, this.camera);
            
            const intersects = raycaster.intersectObjects(
                this.points.map(p => p.sphere)
            );
            
            if (intersects.length > 0) {
                const point = intersects[0].object;
                const data = point.userData.data;
                
                if (this.isMobile) {
                    this.showMobileTooltip(data);
                } else {
                    this.selectPoint(data);
                }
                
                // Highlight the selected point
                this.points.forEach(p => {
                    if (p.sphere === point) {
                        p.sphere.scale.set(1.5, 1.5, 1.5);
                        p.light.intensity = 1.5;
                    } else {
                        p.sphere.scale.set(1, 1, 1);
                        p.light.intensity = 0.3;
                    }
                });
            }
        }
        
        setupUIControls() {
            // Side panel close
            document.getElementById('close-panel').addEventListener('click', () => {
                this.hideSidePanel();
            });
        }
        
        selectPoint(data) {
            this.selectedPoint = data;
            this.showSidePanel();
            this.updateSidePanel();
        }
        
        showMobileTooltip(data) {
            const mobileTooltip = document.getElementById('mobile-tooltip');
            const mobileCategory = document.getElementById('mobile-category');
            const mobileText = document.getElementById('mobile-text');
            const mobileConfidence = document.getElementById('mobile-confidence');
            const mobileStats = document.getElementById('mobile-stats');
            const tooltipOverlay = document.getElementById('tooltip-overlay');
            
            // Set category and style
            let categoryClass = 'mobile-tooltip-hate';
            let categoryText = 'HATE SPEECH';
            
            if (data.true_label_name === 'offensive') {
                categoryClass = 'mobile-tooltip-offensive';
                categoryText = 'OFFENSIVE';
            } else if (data.true_label_name === 'neither') {
                categoryClass = 'mobile-tooltip-neither';
                categoryText = 'NEITHER';
            }
            
            mobileCategory.className = `mobile-tooltip-category ${categoryClass}`;
            mobileCategory.textContent = categoryText;
            
            // Set text (truncated for mobile)
            let text = data.original_text;
            const toxicWords = data.toxic_words || [];
            
            // Highlight toxic words
            toxicWords.forEach(word => {
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                text = text.replace(regex, `<span style="color: #ff3860; font-weight: bold;">${word}</span>`);
            });
            
            // Truncate text if too long
            if (text.length > 200) {
                text = text.substring(0, 200) + '...';
            }
            
            mobileText.innerHTML = text;
            
            // Set confidence
            const confidence = (data.confidence * 100).toFixed(1);
            mobileConfidence.textContent = `${confidence}%`;
            
            // Create stats for mobile
            const entropy = data.entropy.toFixed(3);
            const ambiguity = data.entropy > 0.7 ? 'High' : 'Low';
            const targets = data.semantic_properties.targetSpecificity > 0.5 ? '1-2' : 'Multiple';
            const toxicCount = toxicWords.length;
            
            mobileStats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${entropy}</div>
                    <div class="stat-label">Entropy</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${ambiguity}</div>
                    <div class="stat-label">Ambiguity</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${targets}</div>
                    <div class="stat-label">Targets</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${toxicCount}</div>
                    <div class="stat-label">Toxic Words</div>
                </div>
            `;
            
            // Show tooltip and overlay
            mobileTooltip.classList.add('active');
            tooltipOverlay.classList.add('active');
            
            // Hide after 10 seconds if not interacted with
            clearTimeout(this.mobileTooltipTimeout);
            this.mobileTooltipTimeout = setTimeout(() => {
                this.hideMobileTooltip();
            }, 10000);
        }
        
        hideMobileTooltip() {
            const mobileTooltip = document.getElementById('mobile-tooltip');
            const tooltipOverlay = document.getElementById('tooltip-overlay');
            
            mobileTooltip.classList.remove('active');
            tooltipOverlay.classList.remove('active');
            
            // Reset point highlighting
            this.points.forEach(p => {
                p.sphere.scale.set(1, 1, 1);
                p.light.intensity = 0.3;
            });
        }
        
        showSidePanel() {
            document.getElementById('side-panel').classList.add('active');
        }
        
        hideSidePanel() {
            document.getElementById('side-panel').classList.remove('active');
            
            this.points.forEach(p => {
                p.sphere.scale.set(1, 1, 1);
                p.light.intensity = 0.3;
            });
        }
        
        updateSidePanel() {
            if (!this.selectedPoint) return;
            
            const data = this.selectedPoint;
            
            // Update category tag
            const tag = document.getElementById('category-tag');
            tag.className = 'category-tag ' + `tag-${data.true_label_name.replace('_', '')}`;
            tag.textContent = data.true_label_name.toUpperCase().replace('_', ' ');
            
            if (data.is_misclassified) {
                tag.innerHTML += ` → ${data.predicted_label_name.toUpperCase().replace('_', ' ')}`;
            }
            
            // Update text with toxic words highlighted
            let text = data.original_text;
            const toxicWords = data.toxic_words || [];
            
            toxicWords.forEach(word => {
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                text = text.replace(regex, `<span style="background: rgba(255,56,96,0.3); padding: 0.1rem 0.3rem; border-radius: 3px; color: #ff3860;">${word}</span>`);
            });
            
            document.getElementById('text-content').innerHTML = text;
            
            // Update confidence
            const confidence = (data.confidence * 100).toFixed(1);
            document.getElementById('confidence-value').textContent = `${confidence}%`;
            document.getElementById('confidence-bar').style.width = `${confidence}%`;
            
            // Update stats
            document.getElementById('stat-entropy').textContent = data.entropy.toFixed(3);
            document.getElementById('stat-ambiguity').textContent = data.entropy > 0.7 ? 'High' : 'Low';
            document.getElementById('stat-targets').textContent = 
                data.semantic_properties.targetSpecificity > 0.5 ? '1-2' : 'Multiple';
            document.getElementById('stat-toxic-words').textContent = toxicWords.length;
            
            // Update analysis insights
            this.addAnalysisInsights(data);
        }
        
        addAnalysisInsights(data) {
            const insights = [];
            
            if (data.true_label_name === 'hate_speech') {
                insights.push('🔴 <strong>High Severity</strong>: Contains direct hate speech elements');
                if (data.semantic_properties.offensiveness > 0.8) {
                    insights.push(' <strong>Extreme Language</strong>: Uses highly offensive terminology');
                }
            } else if (data.true_label_name === 'offensive') {
                insights.push('🟡 <strong>Moderate Severity</strong>: Contains offensive but not hateful language');
                insights.push(' <strong>Context Dependent</strong>: May vary based on cultural context');
            } else {
                insights.push('🟢 <strong>Low Severity</strong>: Generally acceptable discourse');
            }
            
            if (data.is_misclassified) {
                insights.push('🔄 <strong>Misclassification</strong>: Model may have misinterpreted context');
            }
            
            if (data.entropy > 0.7) {
                insights.push('🎭 <strong>High Ambiguity</strong>: Multiple interpretations possible');
            }
            
            const insightsHTML = insights.map(insight => 
                `<div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 6px;">${insight}</div>`
            ).join('');
            
            const insightsDiv = document.getElementById('analysis-insights');
            insightsDiv.innerHTML = `
                <div class="control-title">AI Analysis Insights</div>
                ${insightsHTML}
            `;
        }
        
        resetCamera() {
            this.camera.position.set(0, 20, 50);
            this.camera.lookAt(0, 0, 0);
            this.controls.reset();
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            
            this.controls.update();
            
            // Animate word particles with slower speed
            const time = Date.now() * 0.001;
            this.wordParticles.forEach(sprite => {
                sprite.userData.angle += sprite.userData.speed * this.flowSpeed;
                sprite.position.x = Math.cos(sprite.userData.angle) * sprite.userData.radius;
                sprite.position.z = Math.sin(sprite.userData.angle) * sprite.userData.radius;
                sprite.position.y = sprite.userData.originalHeight + Math.sin(time * 0.5 + sprite.userData.angle) * 3;
            });
            
            // Gentle animation for data points
            if (this.flowSpeed > 0.1) {
                this.points.forEach((p, i) => {
                    const wave = Math.sin(time * 1.5 + i * 0.1) * 0.05;
                    p.sphere.position.y += wave * 0.003;
                });
            }
            
            this.renderer.render(this.scene, this.camera);
        }
        
        hideLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen && loadingScreen.style.display !== 'none') {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 300);
            }
        }
        
        showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.position = 'fixed';
            errorDiv.style.top = '50%';
            errorDiv.style.left = '50%';
            errorDiv.style.transform = 'translate(-50%, -50%)';
            errorDiv.style.background = 'rgba(255, 56, 96, 0.9)';
            errorDiv.style.color = 'white';
            errorDiv.style.padding = '2rem';
            errorDiv.style.borderRadius = '12px';
            errorDiv.style.zIndex = '10000';
            errorDiv.innerHTML = `
                <div style="font-size: 1.5rem; margin-bottom: 1rem;">Error Loading Visualization</div>
                <div style="margin-bottom: 1rem;">${message}</div>
                <button onclick="location.reload()" style="
                    background: white;
                    color: #ff3860;
                    border: none;
                    padding: 0.5rem 1rem;
                    border-radius: 5px;
                    cursor: pointer;
                ">Reload Page</button>
            `;
            document.body.appendChild(errorDiv);
        }
    }
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', () => {
        if (typeof THREE === 'undefined') {
            alert('Three.js failed to load. Please check your internet connection.');
            return;
        }
        
        if (typeof THREE.OrbitControls === 'undefined') {
            console.error('OrbitControls not loaded');
            return;
        }
        
        // Start immediately
        window.galaxy = new HateSpeechGalaxy();
    });
    
    // Preload critical resources
    window.addEventListener('load', () => {
        // Preload JSON data
        const preloadLinks = ['HS_analysis_3d.json', 'hate_speech_3d_words.json'];
        preloadLinks.forEach(url => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.as = 'fetch';
            link.href = url;
            document.head.appendChild(link);
        });
    });
    </script>
</body>
</html>