<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hate Speech Analysis | 3D Semantic Visualization</title>
<style>
    :root {
        --bg-primary: #090e14;
        --bg-secondary: #222121;
        --bg-card: rgba(30, 30, 30, 0.95);
        --text-primary: #ffffff;
        --text-secondary: #e0d8d8;
        --accent-silver: #c0c0c0;
        --accent-light: #d4d4d4;
        --accent-dark: #909090;
        --glass-bg: rgba(51, 48, 48, 0.4);
        --glass-border: rgba(211, 207, 207, 0.108);
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.5);
        --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.6);
        --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.7);
        --shadow-xl: 0 24px 64px rgba(0, 0, 0, 0.8);
        --font-mono: 'Courier New', monospace;
        --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        
        --hate-color: #ff6b6b;
        --offensive-color: #eb5409;
        --neither-color: #7bdff2; /* Changed to softer blue */
        --ambiguous-color: #ffd166;
        --misclassified-color: #9d4edd;
        
        /* Control panel */
        --control-panel-width: 320px; /* Wider for narrative */
        --control-panel-compact-width: 60px;
        --tooltip-max-width: 280px;
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
    }
    
    body {
        background: var(--bg-primary);
        color: var(--text-primary);
        font-family: var(--font-sans);
        overflow: hidden;
        height: 100vh;
        position: relative;
        -webkit-overflow-scrolling: touch;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            radial-gradient(circle at 20% 30%, rgba(192, 192, 192, 0.03) 0%, transparent 50%),
            radial-gradient(circle at 80% 70%, rgba(160, 160, 160, 0.02) 0%, transparent 50%);
        pointer-events: none;
        z-index: 1;
    }
    
    .title-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 1rem 1.5rem 1.2rem;
        text-align: center;
        z-index: 100;
        background: linear-gradient(to bottom, rgba(9, 14, 20, 0.95) 0%, transparent 100%);
        pointer-events: none;
    }
    
    .main-title {
        font-size: clamp(1.6rem, 5vw, 3rem);
        font-weight: 300;
        line-height: 1;
        margin-bottom: 0.3rem;
        background: linear-gradient(135deg, 
            #ffffff 0%, 
            #e0e0e0 20%,
            #c0c0c0 60%, 
            #a0a0a0 60%,
            #909090 80%,
            #606060 100%);
        background-size: 200% 200%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: -1px;
        filter: drop-shadow(0 8px 32px rgba(192, 192, 192, 0.4));
    }
    
    .subtitle {
        font-size: clamp(0.5rem, 1.2vw, 0.8rem);
        color: var(--accent-silver);
        font-weight: 400;
        letter-spacing: 0.1rem;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
    }
    
    .dataset-info {
        font-size: 0.75rem;
        color: var(--accent-silver);
        background: rgba(34, 33, 33, 0.5);
        padding: 0.3rem 0.6rem;
        border-radius: 1.5rem;
        display: inline-block;
        border: 1px solid rgba(211, 207, 207, 0.1);
    }
    
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--bg-primary);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        transition: opacity 0.5s ease;
    }
    
    .loading-spinner {
        width: 50px;
        height: 50px;
        position: relative;
        margin-bottom: 1.5rem;
    }
    
    .spinner-ring {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 2px solid transparent;
        border-top: 2px solid var(--accent-silver);
        animation: spin 1.5s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }
    
    .spinner-ring:nth-child(2) {
        border-top-color: var(--accent-light);
        animation-delay: 0.2s;
    }
    
    .spinner-ring:nth-child(3) {
        border-top-color: var(--accent-dark);
        animation-delay: 0.4s;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        font-size: 0.9rem;
        color: var(--accent-silver);
        font-family: var(--font-mono);
        letter-spacing: 0.15rem;
        text-transform: uppercase;
    }
    
    #main-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
        z-index: 0;
        touch-action: none;
    }
    
    /* MODERN FLOATING CONTROL PANEL */
    .control-panel {
        position: fixed;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        width: var(--control-panel-width);
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        border-radius: 20px;
        z-index: 100;
        box-shadow: var(--shadow-xl);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        max-height: 85vh;
    }
    
    .control-panel.compact {
        width: var(--control-panel-compact-width);
    }
    
    /* Panel Header */
    .panel-header {
        padding: 1.2rem 1.5rem;
        background: rgba(255, 255, 255, 0.05);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        user-select: none;
    }
    
    .panel-header:hover {
        background: rgba(255, 255, 255, 0.08);
    }
    
    .panel-title {
        font-size: 0.9rem;
        color: var(--accent-silver);
        text-transform: uppercase;
        letter-spacing: 0.1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .panel-title-icon {
        font-size: 1.2rem;
        color: var(--accent-light);
    }
    
    .toggle-icon {
        color: var(--accent-silver);
        font-size: 1.2rem;
        transition: transform 0.3s ease;
    }
    
    .control-panel.compact .toggle-icon {
        transform: rotate(180deg);
    }
    
    .panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
        transition: opacity 0.3s ease;
    }
    
    .control-panel.compact .panel-content {
        display: none;
    }
    
    /* NARRATIVE SECTION */
    .narrative-section {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 0.5rem;
    }
    
    .narrative-title {
        font-size: 0.8rem;
        color: var(--accent-silver);
        text-transform: uppercase;
        letter-spacing: 0.08rem;
        margin-bottom: 0.6rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .narrative-text {
        font-size: 0.75rem;
        color: var(--text-secondary);
        line-height: 1.5;
        margin-bottom: 0.8rem;
    }
    
    .narrative-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    
    .narrative-stat {
        text-align: center;
        padding: 0.5rem;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 8px;
    }
    
    .stat-value-large {
        font-size: 0.9rem;
        font-weight: 300;
        font-family: var(--font-mono);
        color: var(--accent-silver);
        margin-bottom: 0.15rem;
    }
    
    .stat-label-small {
        font-size: 0.6rem;
        color: var(--accent-dark);
        text-transform: uppercase;
        letter-spacing: 0.05rem;
        line-height: 1.2;
    }
    
    /* Control Groups */
    .control-group {
        margin-bottom: 0;
    }
    
    .control-title {
        font-size: 0.75rem;
        color: var(--accent-silver);
        text-transform: uppercase;
        letter-spacing: 0.08rem;
        margin-bottom: 0.8rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .control-title-icon {
        font-size: 0.9rem;
        opacity: 0.7;
    }
    
    /* Button Groups */
    .btn-group {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.6rem;
        margin-bottom: 0;
    }
    
    .btn-group.three-column {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .btn {
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.12);
        color: var(--accent-light);
        padding: 0.8rem 0.5rem;
        border-radius: 10px;
        cursor: pointer;
        font-size: 0.8rem;
        text-align: center;
        transition: all 0.2s ease;
        font-family: var(--font-mono);
        user-select: none;
        min-height: 46px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.3rem;
        line-height: 1.2;
    }
    
    .btn:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: var(--accent-silver);
        transform: translateY(-1px);
    }
    
    .btn.active {
        background: rgba(192, 192, 192, 0.2);
        border-color: var(--accent-silver);
        color: var(--text-primary);
        box-shadow: 0 0 15px rgba(192, 192, 192, 0.25);
    }
    
    .btn-icon {
        font-size: 1rem;
        opacity: 0.8;
    }
    
    .btn-label {
        font-size: 0.7rem;
        opacity: 0.9;
    }
    
    /* Filter Buttons */
    .filter-group {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
    }
    
    .filter-btn {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        padding: 0.9rem 1rem;
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        color: var(--accent-light);
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.2s ease;
        user-select: none;
        min-height: 50px;
    }
    
    .filter-btn:hover {
        background: rgba(255, 255, 255, 0.12);
        transform: translateX(3px);
    }
    
    .filter-btn.active {
        background: rgba(255, 255, 255, 0.15);
        border-color: var(--accent-silver);
    }
    
    .color-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        box-shadow: 0 0 8px currentColor;
        flex-shrink: 0;
    }
    
    /* Compact Mode (Icon-only) */
    .compact-controls {
        display: none;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1.2rem 0.75rem;
    }
    
    .control-panel.compact .compact-controls {
        display: flex;
    }
    
    .compact-btn {
        width: 42px;
        height: 42px;
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        color: var(--accent-light);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        transition: all 0.2s ease;
        user-select: none;
        position: relative;
    }
    
    .compact-btn:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: var(--accent-silver);
    }
    
    .compact-btn.active {
        background: rgba(192, 192, 192, 0.2);
        border-color: var(--accent-silver);
        color: var(--text-primary);
        box-shadow: 0 0 12px rgba(192, 192, 192, 0.25);
    }
    
    .compact-btn-tooltip {
        position: absolute;
        right: calc(100% + 10px);
        top: 50%;
        transform: translateY(-50%);
        background: var(--bg-card);
        backdrop-filter: blur(10px);
        border: 1px solid var(--glass-border);
        border-radius: 8px;
        padding: 0.6rem 0.9rem;
        color: var(--text-primary);
        font-size: 0.75rem;
        white-space: nowrap;
        display: none;
        z-index: 1000;
        box-shadow: var(--shadow-md);
        pointer-events: none;
    }
    
    /* Mobile: tooltip appears on right side */
    @media (max-width: 768px) {
        .compact-btn-tooltip {
            right: auto;
            left: calc(100% + 10px);
            top: 50%;
            transform: translateY(-50%);
            white-space: nowrap;
        }
    }
    
    .compact-btn:hover .compact-btn-tooltip {
        display: block;
    }
    
    /* COMPACT TOOLTIP - Smaller and faster */
    #tooltip {
        position: fixed;
        background: var(--bg-card);
        backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        border-radius: 12px;
        padding: 0.8rem;
        color: var(--text-primary);
        max-width: 280px;
        pointer-events: none;
        display: none;
        z-index: 1000;
        box-shadow: var(--shadow-xl);
        font-size: 0.75rem;
        line-height: 1.3;
        opacity: 0;
        transform: scale(0.95);
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    
    #tooltip.visible {
        opacity: 1;
        transform: scale(1);
        display: block;
    }
    
    .tooltip-header {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        margin-bottom: 0.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .tooltip-class {
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--accent-silver);
        line-height: 1.2;
        text-transform: uppercase;
        letter-spacing: 0.06rem;
    }
    
    .tooltip-text {
        color: var(--text-secondary);
        margin-bottom: 0.6rem;
        font-size: 0.75rem;
        line-height: 1.4;
        max-height: 100px;
        overflow-y: auto;
        word-break: break-word;
        padding: 0.3rem 0;
    }
    
    .tooltip-metrics {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
    }
    
    .metric {
        background: rgba(255, 255, 255, 0.05);
        padding: 0.5rem;
        border-radius: 6px;
    }
    
    .metric-label {
        font-size: 0.6rem;
        color: var(--accent-dark);
        text-transform: uppercase;
        letter-spacing: 0.06rem;
        margin-bottom: 0.2rem;
    }
    
    .metric-value {
        font-size: 0.8rem;
        font-family: var(--font-mono);
        color: var(--accent-silver);
    }
    
    /* Counterfactual Lab */
    .counterfactual-lab {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        width: 380px;
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 14px;
        padding: 1.25rem;
        z-index: 100;
        box-shadow: var(--shadow-xl);
        display: none;
    }
    
    .lab-title {
        font-size: 1rem;
        color: var(--accent-silver);
        margin-bottom: 0.8rem;
        font-weight: 600;
    }
    
    .text-editor {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 0.9rem;
        font-family: var(--font-mono);
        color: var(--text-primary);
        width: 100%;
        min-height: 90px;
        resize: vertical;
        margin-bottom: 0.8rem;
        font-size: 16px;
    }
    
    .token-visualization {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-bottom: 0.8rem;
    }
    
    .token {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        transition: all 0.3s ease;
    }
    
    .token.hate-influence {
        background: rgba(255, 107, 107, 0.3);
        border-color: var(--hate-color);
        box-shadow: 0 0 12px rgba(255, 107, 107, 0.5);
    }
    
    .token.offensive-influence {
        background: rgba(235, 84, 9, 0.3);
        border-color: var(--offensive-color);
        box-shadow: 0 0 12px rgba(235, 84, 9, 0.5);
    }
    
    .token.neither-influence {
        background: rgba(123, 223, 242, 0.3);
        border-color: var(--neither-color);
        box-shadow: 0 0 12px rgba(123, 223, 242, 0.5);
    }
    
    /* Instructions */
    .instructions {
        position: fixed;
        bottom: 1.5rem;
        left: 50%;
        transform: translateX(-50%);
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 100px;
        padding: 0.7rem 1.5rem;
        color: var(--accent-silver);
        font-size: 0.75rem;
        white-space: nowrap;
        z-index: 100;
        max-width: 90%;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    /* Error Display */
    #error-display {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 107, 107, 0.95);
        backdrop-filter: blur(20px);
        color: white;
        padding: 1.5rem;
        border-radius: 14px;
        max-width: 450px;
        display: none;
        z-index: 10001;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .error-title {
        font-size: 1.3rem;
        margin-bottom: 0.8rem;
        font-weight: 600;
    }
    
    /* Word Cloud Overlay */
    .viz-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(8, 12, 24, 0.96);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        opacity: 1;
        transition: opacity 0.35s ease;
    }
    
    .viz-overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }
    
    .viz-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.9rem 1.25rem;
        background: rgba(15, 20, 40, 0.95);
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .viz-title {
        font-size: 0.8rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: #cfd8ff;
    }
    
    #closeViz {
        background: none;
        border: none;
        color: #9aa8ff;
        font-size: 0.8rem;
        cursor: pointer;
        padding: 0.4rem;
        min-height: 38px;
    }
    
    #closeViz:hover {
        color: #ffffff;
    }
    
    #vizFrame {
        flex: 1;
        width: 100%;
        height: 100%;
        border: none;
    }
    
    /* MOBILE RESPONSIVE STYLES */
    @media (max-width: 1200px) {
        :root {
            --control-panel-width: 300px;
        }
        
        .control-panel {
            right: 15px;
        }
    }
    
    @media (max-width: 992px) {
        :root {
            --control-panel-width: 280px;
        }
        
        .title-container {
            padding: 0.8rem 1.2rem 1rem;
        }
        
        .main-title {
            font-size: clamp(1.4rem, 4vw, 2.5rem);
        }
        
        .btn {
            padding: 0.7rem 0.4rem;
            min-height: 44px;
        }
        
        .filter-btn {
            padding: 0.8rem 0.9rem;
            min-height: 48px;
        }
    }
    
    @media (max-width: 768px) {
        /* MOBILE OPTIMIZED LAYOUT */
        :root {
            --control-panel-width: 90vw;
            --control-panel-compact-width: 60px;
        }
        
        .title-container {
            padding: 0.6rem 1rem 0.8rem;
        }
        
        .main-title {
            font-size: clamp(1.2rem, 3.5vw, 2rem);
            margin-bottom: 0.2rem;
        }
        
        .subtitle {
            font-size: 0.55rem;
            letter-spacing: 0.08rem;
        }
        
        /* Mobile control panel - bottom positioned */
        .control-panel {
            position: fixed;
            top: auto;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            right: auto;
            width: 95vw;
            max-width: 500px;
            max-height: 70vh;
            border-radius: 20px 20px 20px 20px;
        }
        
        .panel-header {
            padding: 1rem 1.2rem;
        }
        
        .panel-content {
            padding: 1rem;
            gap: 1rem;
        }
        
        .narrative-section {
            padding: 0.8rem;
            margin-bottom: 0.3rem;
        }
        
        .narrative-text {
            font-size: 0.7rem;
        }
        
        .btn-group {
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }
        
        .btn-group.three-column {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .btn {
            min-height: 44px;
            padding: 0.7rem 0.5rem;
        }
        
        .filter-btn {
            min-height: 46px;
            padding: 0.8rem 0.8rem;
        }
        
        .compact-controls {
            padding: 1rem 0.5rem;
            gap: 0.6rem;
        }
        
        .compact-btn {
            width: 44px;
            height: 44px;
            font-size: 1.1rem;
        }
        
        /* MOBILE TOOLTIP - Position on right side */
        #tooltip {
            max-width: 85vw;
            font-size: 0.75rem;
            padding: 0.7rem;
            right: 10px !important;
            left: auto !important;
            bottom: 100px !important;
            top: auto !important;
            transform: translateY(0) !important;
        }
        
        #tooltip.visible {
            transform: scale(1) !important;
        }
        
        .tooltip-text {
            font-size: 0.7rem;
            max-height: 80px;
        }
        
        .instructions {
            display: none;
        }
        
        .counterfactual-lab {
            width: calc(100% - 2rem);
            right: 1rem;
            left: 1rem;
            max-height: 65vh;
            overflow-y: auto;
            bottom: 1rem;
        }
    }
    
    @media (max-width: 480px) {
        :root {
            --control-panel-width: 95vw;
        }
        
        .title-container {
            padding: 0.5rem 0.8rem 0.6rem;
        }
        
        .main-title {
            font-size: 1.2rem;
        }
        
        .subtitle {
            font-size: 0.5rem;
        }
        
        .dataset-info {
            font-size: 0.65rem;
            padding: 0.25rem 0.5rem;
        }
        
        .control-panel {
            bottom: 10px;
        }
        
        .panel-header {
            padding: 0.8rem 1rem;
        }
        
        .panel-content {
            padding: 0.8rem;
            gap: 0.8rem;
        }
        
        .btn-group.three-column {
            grid-template-columns: 1fr;
        }
        
        .btn {
            min-height: 42px;
            padding: 0.6rem 0.4rem;
            font-size: 0.75rem;
        }
        
        .filter-btn {
            min-height: 44px;
            padding: 0.7rem 0.7rem;
            font-size: 0.75rem;
        }
        
        .color-indicator {
            width: 10px;
            height: 10px;
        }
        
        #tooltip {
            padding: 0.6rem;
            bottom: 90px !important;
            right: 8px !important;
        }
    }
    
    @media (max-width: 360px) {
        .main-title {
            font-size: 1.1rem;
        }
        
        .btn-group {
            gap: 0.4rem;
        }
        
        .btn {
            font-size: 0.72rem;
            min-height: 40px;
        }
        
        .filter-btn {
            font-size: 0.72rem;
            min-height: 42px;
        }
    }
    
    /* Scrollbar styling */
    .panel-content::-webkit-scrollbar {
        width: 6px;
    }
    
    .panel-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
    }
    
    .panel-content::-webkit-scrollbar-thumb {
        background: rgba(192, 192, 192, 0.3);
        border-radius: 3px;
    }
    
    .panel-content::-webkit-scrollbar-thumb:hover {
        background: rgba(192, 192, 192, 0.5);
    }
    
    /* Touch feedback */
    .touch-feedback:active {
        transform: scale(0.96);
        opacity: 0.8;
        transition: transform 0.1s ease;
    }
    
    /* Mobile gesture indicator */
    .gesture-indicator {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 11px;
        display: none;
        z-index: 1000;
        pointer-events: none;
        transition: opacity 0.3s;
        text-align: center;
        max-width: 90%;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .gesture-indicator.visible {
        display: block;
        opacity: 1;
        animation: fadeInOut 3s ease-in-out;
    }
    
    @keyframes fadeInOut {
        0%, 100% { opacity: 0; }
        20%, 80% { opacity: 1; }
    }
</style>
</head>
<body>
    <div class="title-container">
        <div class="main-title">Hate Speech Analysis</div>
        <div class="subtitle">3D Semantic Visualization</div>
    </div>

    <div id="loading-screen">
        <div class="loading-spinner">
            <div class="spinner-ring"></div>
            <div class="spinner-ring"></div>
            <div class="spinner-ring"></div>
        </div>
        <div class="loading-text">Loading Visualization</div>
    </div>

    <canvas id="main-canvas"></canvas>

    <!-- MODERN FLOATING CONTROL PANEL -->
    <div class="control-panel" id="controlPanel">
        <div class="panel-header" id="panelToggle">
            <div class="panel-title">
                <span class="panel-title-icon">‚öôÔ∏è</span>
                <span>Visualization Guide</span>
            </div>
            <div class="toggle-icon">‚Ä∫</div>
        </div>
        
        <!-- Expanded View -->
        <div class="panel-content">
            <!-- Narrative Section -->
            <div class="narrative-section">
                <div class="narrative-title">Understanding the Data</div>
                <div class="narrative-text">
                    This visualization explores <strong>24,783 tweets</strong> analyzed for hate speech content. Each point represents a tweet positioned in 3D semantic space based on its linguistic features.
                </div>
                <div class="narrative-stats">
                    <div class="narrative-stat">
                        <div class="stat-value-large">1,430</div>
                        <div class="stat-label-small" style="color: var(--hate-color);">Hate Speech</div>
                    </div>
                    <div class="narrative-stat">
                        <div class="stat-value-large">19,190</div>
                        <div class="stat-label-small" style="color: var(--offensive-color);">Offensive</div>
                    </div>
                    <div class="narrative-stat">
                        <div class="stat-value-large">4,163</div>
                        <div class="stat-label-small" style="color: var(--neither-color);">Neither</div>
                    </div>
                </div>
                <div class="narrative-text" style="margin-top: 0.8rem; font-size: 0.7rem;">
                    <strong>Interactivity:</strong> Zoom with scroll/pinch, rotate by dragging. Click points for details. Use filters below to explore patterns.
                </div>
            </div>
            
            <!-- Visualization Mode -->
            <div class="control-group">
                <div class="control-title">
                    <span class="control-title-icon">üé®</span>
                    Color Mode
                </div>
                <div class="btn-group three-column">
                    <button class="btn active" data-mode="semantic">
                        <span class="btn-icon"></span>
                        <span class="btn-label">By Class</span>
                    </button>
                    <button class="btn" data-mode="ambiguity">
                        <span class="btn-icon"></span>
                        <span class="btn-label">Ambiguity</span>
                    </button>
                    <button class="btn" id="wordCloudBtn">
                        <span class="btn-icon">‚òÅÔ∏è</span>
                        <span class="btn-label">Word Cloud</span>
                    </button>
                </div>
            </div>
            
            <!-- Display Labels -->
            <div class="control-group">
                <div class="control-title">
                    <span class="control-title-icon">üè∑Ô∏è</span>
                    Label Display
                </div>
                <div class="btn-group three-column">
                    <button class="btn active" data-labels="true">
                        <span class="btn-label">True Labels</span>
                    </button>
                    <button class="btn" data-labels="predicted">
                        <span class="btn-label">Predicted</span>
                    </button>
                    <button class="btn" data-labels="difference">
                        <span class="btn-label">Difference</span>
                    </button>
                </div>
            </div>
            
            <!-- Filter Classes -->
            <div class="control-group">
                <div class="control-title">
                    <span class="control-title-icon">üîç</span>
                    Filter Classes
                </div>
                <div class="filter-group">
                    <button class="filter-btn active" data-class="hate_speech">
                        <div class="color-indicator" style="background: var(--hate-color);"></div>
                        <span>Hate Speech (5.8%)</span>
                    </button>
                    <button class="filter-btn active" data-class="offensive">
                        <div class="color-indicator" style="background: var(--offensive-color);"></div>
                        <span>Offensive (77.4%)</span>
                    </button>
                    <button class="filter-btn active" data-class="neither">
                        <div class="color-indicator" style="background: var(--neither-color);"></div>
                        <span>Neither (16.8%)</span>
                    </button>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="control-group">
                <div class="control-title">
                    <span class="control-title-icon">‚ö°</span>
                    Actions
                </div>
                <div class="btn-group">
                    <button class="btn" id="toggle-lab">
                        <span class="btn-icon">üß™</span>
                        <span class="btn-label">Text Lab</span>
                    </button>
                    <button class="btn" id="reset-view">
                        <span class="btn-icon">‚Ü∫</span>
                        <span class="btn-label">Reset View</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Compact View (Icon-only) -->
        <div class="compact-controls">
            <button class="compact-btn" id="compact-filter-hate" title="Hate Speech">
                <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--hate-color);"></div>
                <span class="compact-btn-tooltip">Hate Speech</span>
            </button>
            <button class="compact-btn" id="compact-filter-offensive" title="Offensive">
                <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--offensive-color);"></div>
                <span class="compact-btn-tooltip">Offensive</span>
            </button>
            <button class="compact-btn" id="compact-filter-neither" title="Neither">
                <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--neither-color);"></div>
                <span class="compact-btn-tooltip">Neither</span>
            </button>
            <button class="compact-btn" id="compact-reset" title="Reset View">
                <span>‚Ü∫</span>
                <span class="compact-btn-tooltip">Reset View</span>
            </button>
            <button class="compact-btn" id="compact-lab" title="Text Lab">
                <span>üß™</span>
                <span class="compact-btn-tooltip">Text Lab</span>
            </button>
        </div>
    </div>

    <div id="tooltip"></div>

    <div class="counterfactual-lab">
        <div class="lab-title">Text Analysis Lab</div>
        <div class="token-visualization" id="token-viz"></div>
        <textarea class="text-editor" id="text-editor" placeholder="Enter text to analyze sentiment and classification..."></textarea>
        <div class="btn-group">
            <button class="btn" id="analyze-text">Analyze</button>
            <button class="btn" id="reset-text">Reset</button>
            <button class="btn" id="close-lab">Close</button>
        </div>
    </div>

    <div class="instructions">
        Drag to rotate ‚Ä¢ Scroll/Pinch to zoom ‚Ä¢ Click points for details ‚Ä¢ R to reset ‚Ä¢ L for lab
    </div>

    <div id="error-display">
        <div class="error-title">Error Loading Visualization</div>
        <div id="error-message"></div>
        <button class="btn" onclick="location.reload()" style="margin-top: 1rem;">Reload Page</button>
    </div>

    <!-- Word Cloud Overlay -->
    <div id="vizOverlay" class="viz-overlay hidden">
        <div class="viz-header">
            <span class="viz-title">Word Cloud Visualization</span>
            <button id="closeViz">‚Üê Back to 3D View</button>
        </div>
        <iframe id="vizFrame" src="" frameborder="0" loading="lazy"></iframe>
    </div>

    <!-- Mobile gesture indicator -->
    <div class="gesture-indicator" id="gestureIndicator">Pinch to zoom ‚Ä¢ Drag to rotate</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    class HateSpeechVisualization {
        constructor() {
            // Configuration
            this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
            this.totalPoints = 24783;
            this.classCounts = {
                hate_speech: 1430,
                offensive: 19190,
                neither: 4163
            };
            
            // Core Three.js
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.raycaster = null;
            this.tooltipTimeout = null;
            this.mouse = new THREE.Vector2();
            
            // Touch state
            this.touchStartX = 0;
            this.touchStartY = 0;
            this.touchStartZoom = 45; // More zoomed out
            this.isPinching = false;
            this.initialPinchDistance = 0;
            this.lastTouchTime = 0;
            this.isDragging = false;
            
            // Zoom limits - wider range for better zooming
            this.minZoom = 15;
            this.maxZoom = 150;
            this.zoomSensitivity = 0.8; // Less sensitive zoom
            
            // Visualization state
            this.currentMode = 'semantic';
            this.currentLabels = 'true';
            this.selectedClasses = ['hate_speech', 'offensive', 'neither'];
            this.ambientRotation = true;
            this.isUserInteracting = false;
            
            // Data storage
            this.data = [];
            this.filteredData = [];
            this.points = null;
            
            // Performance optimization
            this.maxRenderPoints = this.isMobile ? 2500 : 6000;
            
            // Panel state
            this.isPanelCompact = false;
            
            // Smooth zoom animation
            this.targetZoom = null;
            this.zoomAnimationId = null;
            this.zoomSpeed = 0.1;
            
            // Pinch zoom tracking
            this.lastPinchDistance = 0;
            this.pinchVelocity = 0;
            
            this.init();
        }
        
        async init() {
            try {
                this.setupThreeJS();
                await this.loadAndGenerateData();
                this.createVisualization();
                this.setupEventListeners();
                this.setupCompactControls();
                this.animate();
                
                setTimeout(() => {
                    document.getElementById('loading-screen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.display = 'none';
                    }, 500);
                }, 100);
                
                // Auto-collapse panel on mobile after delay
                if (this.isMobile) {
                    setTimeout(() => {
                        this.togglePanel();
                        this.showGestureIndicator();
                    }, 2000);
                }
                
                console.log('3D Visualization initialized for ' + (this.isMobile ? 'mobile' : 'desktop'));
                
            } catch (error) {
                console.error('Initialization error:', error);
                this.showError(error.message);
            }
        }
        
        setupThreeJS() {
            // Scene
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x090e14);
            
            // Camera - Start more zoomed OUT for better overview
            this.camera = new THREE.PerspectiveCamera(
                65, // Slightly wider FOV
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            this.camera.position.set(0, 25, 45); // Much further back
            this.camera.lookAt(0, 0, 0);
            
            // Renderer
            const canvas = document.getElementById('main-canvas');
            this.renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: !this.isMobile,
                alpha: true,
                powerPreference: this.isMobile ? "low-power" : "high-performance"
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, this.isMobile ? 1.5 : 2));
            
            // Mobile-specific optimizations
            if (this.isMobile) {
                this.maxRenderPoints = 2500;
            }
            
            // Minimal lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(30, 50, 30);
            this.scene.add(directionalLight);
            
            // Add some depth with fog
            this.scene.fog = new THREE.Fog(0x090e14, 30, 100);
            
            // Raycaster
            this.raycaster = new THREE.Raycaster();
        }
        
        async loadAndGenerateData() {
            console.log('Generating 3D visualization data...');
            
            // Try to load real data first
            try {
                const response = await fetch('HS_analysis_results.json');
                if (response.ok) {
                    const rawData = await response.json();
                    this.processRealData(rawData);
                    return;
                }
            } catch (error) {
                console.log('No real data found, generating synthetic data...');
            }
            
            // Generate 3D scatter plot data with meaningful clusters
            this.data = [];
            let id = 0;
            
            // Generate hate speech points - more clustered
            for (let i = 0; i < this.classCounts.hate_speech; i++) {
                this.data.push(this.createDataPoint(id++, 'hate_speech', true));
            }
            
            // Generate offensive language points - spread out
            for (let i = 0; i < this.classCounts.offensive; i++) {
                this.data.push(this.createDataPoint(id++, 'offensive', false));
            }
            
            // Generate neither points - scattered throughout
            for (let i = 0; i < this.classCounts.neither; i++) {
                this.data.push(this.createDataPoint(id++, 'neither', false));
            }
            
            this.filteredData = this.data.slice(0, this.maxRenderPoints);
            this.updateStats();
        }
        
        createDataPoint(id, trueLabel, isClustered = false) {
            // Generate position with different distributions per class
            let x, y, z;
            const spread = 35;
            
            if (isClustered && trueLabel === 'hate_speech') {
                // Hate speech points are more clustered
                const clusterCenterX = (Math.random() - 0.5) * 20;
                const clusterCenterZ = (Math.random() - 0.5) * 20;
                x = clusterCenterX + (Math.random() - 0.5) * 8;
                z = clusterCenterZ + (Math.random() - 0.5) * 8;
                y = Math.random() * 15;
            } else {
                // Other points more spread out
                x = (Math.random() - 0.5) * spread;
                z = (Math.random() - 0.5) * spread;
                y = Math.random() * 20;
            }

            // Simulate realistic prediction patterns
            let predictedLabel = trueLabel;
            const isMisclassified = Math.random() < 0.15; // 15% misclassification rate
            
            if (isMisclassified) {
                const labels = ['hate_speech', 'offensive', 'neither'];
                const currentIndex = labels.indexOf(trueLabel);
                predictedLabel = labels[(currentIndex + 1) % labels.length];
            }
            
            // Calculate semantic properties
            const entropy = Math.random();
            const confidence = 0.6 + Math.random() * 0.4;
            
            // Sample texts based on class
            let sampleText = "";
            if (trueLabel === 'hate_speech') {
                const texts = [
                    "Targeted hate speech directed at specific groups...",
                    "Harmful rhetoric with discriminatory intent...",
                    "Explicit hate content violating community standards...",
                    "Dangerous speech inciting violence or hatred..."
                ];
                sampleText = texts[Math.floor(Math.random() * texts.length)];
            } else if (trueLabel === 'offensive') {
                const texts = [
                    "Offensive language with inappropriate content...",
                    "Profanity and vulgar expressions detected...",
                    "Insulting remarks with offensive terminology...",
                    "Content containing offensive slang and terms..."
                ];
                sampleText = texts[Math.floor(Math.random() * texts.length)];
            } else {
                const texts = [
                    "Neutral conversational content analyzed...",
                    "Regular discussion without offensive elements...",
                    "Casual conversation meeting community guidelines...",
                    "Standard communication without hate indicators..."
                ];
                sampleText = texts[Math.floor(Math.random() * texts.length)];
            }
            
            return {
                id,
                original_text: `[${trueLabel.toUpperCase()}] ${sampleText} (Sample #${id})`,
                true_label_name: trueLabel,
                predicted_label_name: predictedLabel,
                position_3d: [x, y, z],
                entropy,
                confidence,
                is_ambiguous_flag: entropy > 0.7,
                is_misclassified: isMisclassified,
                cluster_id: Math.floor(id / 500)
            };
        }
        
        processRealData(rawData) {
            // Process real data
            this.data = rawData.slice(0, this.maxRenderPoints).map((item, index) => {
                const position = item.position_3d || [
                    (Math.random() - 0.5) * 35,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 35
                ];
                
                return {
                    id: index,
                    original_text: item.original_text || `Text sample #${index}`,
                    true_label_name: String(item.true_label_name || 'neither').toLowerCase(),
                    predicted_label_name: String(item.predicted_label_name || 'neither').toLowerCase(),
                    position_3d: position,
                    entropy: parseFloat(item.entropy) || Math.random(),
                    confidence: parseFloat(item.confidence) || 0.5 + Math.random() * 0.5,
                    is_ambiguous_flag: Boolean(item.is_ambiguous_flag),
                    is_misclassified: item.true_label_name !== item.predicted_label_name,
                    cluster_id: Math.floor(index / 500)
                };
            });
            
            this.filteredData = this.data;
            this.updateStats();
        }
        
        createVisualization() {
            this.clearScene();
            this.create3DScatterPlot();
            this.updateStats();
        }
        
        clearScene() {
            // Clear points safely
            if (this.points && this.points.geometry && this.points.material) {
                try {
                    if (this.points.geometry) this.points.geometry.dispose();
                    if (this.points.material) this.points.material.dispose();
                    this.scene.remove(this.points);
                } catch (e) {
                    console.warn('Error disposing points:', e);
                }
            }
            this.points = null;
        }
        
        create3DScatterPlot() {
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const pointIndices = [];
            
            let pointIndex = 0;
            this.filteredData.forEach((point, index) => {
                if (!this.selectedClasses.includes(point.true_label_name)) return;
                
                const [x, y, z] = point.position_3d;
                positions.push(x, y, z);
                
                // Color based on current mode
                let color;
                if (this.currentMode === 'ambiguity') {
                    // Color by ambiguity - grayscale
                    const grayValue = 0.4 + point.entropy * 0.6;
                    color = new THREE.Color(grayValue, grayValue, grayValue);
                } else {
                    // Color by class with the new softer blue for neither
                    switch(this.currentLabels === 'true' ? point.true_label_name : point.predicted_label_name) {
                        case 'hate_speech':
                            color = new THREE.Color(0xff6b6b); // Red
                            break;
                        case 'offensive':
                            color = new THREE.Color(0xd83307); // Orange
                            break;
                        case 'neither':
                            color = new THREE.Color(0x7bdff2); // Soft blue 
                            break;
                        default:
                            color = new THREE.Color(0x909090);
                    }
                }
                
                colors.push(color.r, color.g, color.b);
                // Size based on confidence and zoom level
                const baseSize = this.isMobile ? 2 : 2.5;
                sizes.push(point.confidence * baseSize + 0.5);
                pointIndices.push(index);
            });
            
            if (positions.length === 0) {
                console.warn('No points to display with current filters');
                return;
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            // Create material with better point rendering
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    fogColor: { value: new THREE.Color(0x090e14) },
                    fogNear: { value: 30 },
                    fogFar: { value: 100 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    uniform float fogNear;
                    uniform float fogFar;
                    
                    void main() {
                        vColor = color;
                        vec3 pos = position;
                        
                        // Subtle floating animation for visual interest
                        float animation = sin(time * 0.3 + position.x * 0.05 + position.z * 0.05) * 0.1;
                        pos.y += animation;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        
                        // Dynamic point size based on distance and confidence
                        float pointSize = size * (${this.isMobile ? '500.0' : '600.0'} / -mvPosition.z);
                        pointSize = clamp(pointSize, 2.0, 15.0);
                        
                        gl_PointSize = pointSize;
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Fog calculation
                        float depth = gl_Position.z / gl_Position.w;
                        float fogFactor = smoothstep(fogNear, fogFar, depth);
                        vColor = mix(vColor, vec3(0.06, 0.11, 0.2), fogFactor * 0.5);
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        // Create circular points with soft edges
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        float dist = length(coord);
                        
                        if (dist > 0.5) discard;
                        
                        // Soft edge with inner glow
                        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                        float innerGlow = 1.0 - smoothstep(0.0, 0.3, dist);
                        
                        // Combine base color with inner glow
                        vec3 finalColor = mix(vColor, vec3(1.0), innerGlow * 0.3);
                        
                        gl_FragColor = vec4(finalColor, alpha * 0.85);
                    }
                `,
                transparent: true,
                depthWrite: false,
                fog: true
            });
            
            this.points = new THREE.Points(geometry, material);
            this.points.userData = { 
                type: 'scatter', 
                points: this.filteredData,
                pointIndices: pointIndices 
            };
            this.scene.add(this.points);
        }
        
        setupEventListeners() {
            const canvas = document.getElementById('main-canvas');
            
            // ===== IMPROVED ZOOM CONTROLS =====
            
            // Mouse wheel zoom with smooth interpolation and better sensitivity
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.isUserInteracting = true;
                
                // Calculate zoom factor based on delta
                const zoomFactor = Math.pow(0.95, Math.abs(e.deltaY) * 0.01);
                const direction = e.deltaY > 0 ? 1 : -1;
                const currentDistance = this.camera.position.length();
                const targetDistance = THREE.MathUtils.clamp(
                    currentDistance * (direction > 0 ? zoomFactor : 1/zoomFactor),
                    this.minZoom,
                    this.maxZoom
                );
                
                // Smooth zoom animation
                this.animateZoom(targetDistance);
                
                // Reset user interaction flag after delay
                setTimeout(() => {
                    this.isUserInteracting = false;
                }, 150);
            }, { passive: false });
            
            // ===== IMPROVED MOBILE TOUCH CONTROLS =====
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.isUserInteracting = true;
                
                if (e.touches.length === 1) {
                    // Single touch for rotation
                    const touch = e.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                    
                    // Update mouse for raycasting
                    const rect = canvas.getBoundingClientRect();
                    this.mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Double tap detection
                    const currentTime = Date.now();
                    if (currentTime - this.lastTouchTime < 300) {
                        // Double tap - reset view
                        this.resetView();
                    }
                    this.lastTouchTime = currentTime;
                } 
                else if (e.touches.length === 2) {
                    // Pinch to zoom - start
                    this.isPinching = true;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    this.initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                    this.lastPinchDistance = this.initialPinchDistance;
                    this.touchStartZoom = this.camera.position.length();
                    this.pinchVelocity = 0;
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                this.isUserInteracting = true;
                
                if (e.touches.length === 1 && !this.isPinching) {
                    // Single touch drag for rotation
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touchStartX;
                    const deltaY = touch.clientY - this.touchStartY;
                    
                    // Smoother rotation with momentum
                    const rotationSpeed = 0.008; // Slower for better control
                    const spherical = new THREE.Spherical().setFromVector3(this.camera.position);
                    spherical.theta -= deltaX * rotationSpeed;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + deltaY * rotationSpeed));
                    
                    this.camera.position.setFromSpherical(spherical);
                    this.camera.lookAt(0, 0, 0);
                    
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                }
                else if (e.touches.length === 2) {
                    // Pinch zoom with smooth interpolation
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (this.initialPinchDistance > 0) {
                        // Calculate zoom factor with momentum
                        const zoomFactor = currentDistance / this.initialPinchDistance;
                        const targetDistance = THREE.MathUtils.clamp(
                            this.touchStartZoom / zoomFactor,
                            this.minZoom,
                            this.maxZoom
                        );
                        
                        // Update pinch velocity for momentum
                        this.pinchVelocity = (currentDistance - this.lastPinchDistance) / 16;
                        this.lastPinchDistance = currentDistance;
                        
                        // Apply zoom
                        this.camera.position.normalize().multiplyScalar(targetDistance);
                        this.camera.lookAt(0, 0, 0);
                    }
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                this.isUserInteracting = false;
                
                if (e.touches.length < 2) {
                    // Apply momentum if we were pinching
                    if (this.isPinching && Math.abs(this.pinchVelocity) > 0.5) {
                        const currentDistance = this.camera.position.length();
                        const momentumDistance = THREE.MathUtils.clamp(
                            currentDistance * (1 - this.pinchVelocity * 0.1),
                            this.minZoom,
                            this.maxZoom
                        );
                        this.animateZoom(momentumDistance);
                    }
                    
                    this.isPinching = false;
                    this.initialPinchDistance = 0;
                    this.pinchVelocity = 0;
                }
                
                // Single touch end - show tooltip if clicked a point
                if (e.changedTouches.length === 1 && !this.isDragging) {
                    const touch = e.changedTouches[0];
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    
                    // Check for point clicks
                    if (this.points) {
                        const intersects = this.raycaster.intersectObject(this.points);
                        if (intersects.length > 0) {
                            const index = intersects[0].index;
                            const pointData = this.points.userData;
                            if (pointData && pointData.pointIndices && pointData.pointIndices[index] !== undefined) {
                                const point = this.filteredData[pointData.pointIndices[index]];
                                if (point) {
                                    // Show tooltip at touch position
                                    this.showTooltip(point, touch.clientX, touch.clientY);
                                }
                            }
                        }
                    }
                }
            }, { passive: false });
            
            // ===== DESKTOP CONTROLS =====
            let lastX = 0;
            let lastY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                if (this.isMobile) return;
                this.isDragging = true;
                this.isUserInteracting = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (this.isMobile) return;
                
                // Update mouse for raycasting
                const rect = canvas.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Rotation
                if (this.isDragging) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    
                    const rotationSpeed = 0.008; // Smoother rotation
                    const spherical = new THREE.Spherical().setFromVector3(this.camera.position);
                    spherical.theta -= deltaX * rotationSpeed;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + deltaY * rotationSpeed));
                    
                    this.camera.position.setFromSpherical(spherical);
                    this.camera.lookAt(0, 0, 0);
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if (this.isMobile) return;
                this.isDragging = false;
                this.isUserInteracting = false;
                canvas.style.cursor = 'default';
            });
            
            // Click for details
            canvas.addEventListener('click', (e) => {
                if (this.isMobile) return;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Check for point clicks
                if (this.points) {
                    const intersects = this.raycaster.intersectObject(this.points);
                    if (intersects.length > 0) {
                        const index = intersects[0].index;
                        const pointData = this.points.userData;
                        if (pointData && pointData.pointIndices && pointData.pointIndices[index] !== undefined) {
                            const point = this.filteredData[pointData.pointIndices[index]];
                            if (point) {
                                this.showTooltip(point, e.clientX, e.clientY);
                            }
                        }
                    }
                }
            });
            
            // ===== COMMON CONTROLS =====
            // Window resize
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Update mobile detection
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'r':
                        this.resetView();
                        break;
                    case 'l':
                        this.toggleCounterfactualLab();
                        break;
                    case 'tab':
                        e.preventDefault();
                        this.togglePanel();
                        break;
                    case 'escape':
                        this.hideTooltip();
                        break;
                    case '+':
                    case '=':
                        e.preventDefault();
                        this.animateZoom(this.camera.position.length() * 0.85);
                        break;
                    case '-':
                    case '_':
                        e.preventDefault();
                        this.animateZoom(this.camera.position.length() * 1.15);
                        break;
                }
            });
            
            // ===== PANEL CONTROLS =====
            this.setupPanelControls();
        }
        
        animateZoom(targetDistance) {
            if (this.zoomAnimationId) {
                cancelAnimationFrame(this.zoomAnimationId);
            }
            
            const startDistance = this.camera.position.length();
            const startTime = performance.now();
            const duration = 250; // ms - slightly longer for smoother feel
            
            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease out cubic for smooth feeling
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                const currentDistance = startDistance + (targetDistance - startDistance) * easeProgress;
                
                this.camera.position.normalize().multiplyScalar(currentDistance);
                this.camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    this.zoomAnimationId = requestAnimationFrame(animate);
                } else {
                    this.zoomAnimationId = null;
                }
            };
            
            this.zoomAnimationId = requestAnimationFrame(animate);
        }
        
        setupPanelControls() {
            const panel = document.getElementById('controlPanel');
            const panelToggle = document.getElementById('panelToggle');
            
            // Panel toggle
            panelToggle.addEventListener('click', () => {
                this.togglePanel();
            });
            
            // Add touch feedback to all buttons
            document.querySelectorAll('.btn, .filter-btn, .compact-btn').forEach(btn => {
                btn.addEventListener('touchstart', () => {
                    btn.classList.add('touch-feedback');
                });
                btn.addEventListener('touchend', () => {
                    setTimeout(() => btn.classList.remove('touch-feedback'), 150);
                });
            });
            
            // Mode buttons
            document.querySelectorAll('.btn[data-mode]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('.btn[data-mode]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.currentMode = btn.dataset.mode;
                    this.createVisualization();
                });
            });
            
            // Label buttons
            document.querySelectorAll('.btn[data-labels]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('.btn[data-labels]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.currentLabels = btn.dataset.labels;
                    this.createVisualization();
                });
            });
            
            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    btn.classList.toggle('active');
                    const className = btn.dataset.class;
                    
                    if (btn.classList.contains('active')) {
                        if (!this.selectedClasses.includes(className)) {
                            this.selectedClasses.push(className);
                        }
                    } else {
                        this.selectedClasses = this.selectedClasses.filter(c => c !== className);
                    }
                    
                    this.filterData();
                    this.updateCompactFilterButtons();
                });
            });
            
            // Toggle buttons
            document.getElementById('toggle-lab').addEventListener('click', (e) => {
                e.preventDefault();
                this.toggleCounterfactualLab();
            });
            
            document.getElementById('reset-view').addEventListener('click', (e) => {
                e.preventDefault();
                this.resetView();
            });
            
            // Counterfactual lab controls
            document.getElementById('close-lab').addEventListener('click', () => {
                this.toggleCounterfactualLab();
            });
            
            document.getElementById('analyze-text').addEventListener('click', () => {
                this.analyzeCounterfactual();
            });
            
            document.getElementById('reset-text').addEventListener('click', () => {
                document.getElementById('text-editor').value = '';
                document.getElementById('token-viz').innerHTML = '';
            });
            
            // Word Cloud button
            const wordCloudBtn = document.getElementById('wordCloudBtn');
            if (wordCloudBtn) {
                wordCloudBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    // Show word cloud overlay
                    const vizOverlay = document.getElementById('vizOverlay');
                    const vizFrame = document.getElementById('vizFrame');
                    
                    if (vizOverlay && vizFrame) {
                        // Load the word cloud page
                        vizFrame.src = "word_cloud.html";
                        vizOverlay.classList.remove("hidden");
                        document.body.style.overflow = "hidden";
                        
                        // Hide tooltip if visible
                        this.hideTooltip();
                    }
                });
            }
            
            // Word Cloud close button
            const closeVizBtn = document.getElementById('closeViz');
            if (closeVizBtn) {
                closeVizBtn.addEventListener('click', () => {
                    const vizOverlay = document.getElementById('vizOverlay');
                    const vizFrame = document.getElementById('vizFrame');
                    
                    if (vizOverlay && vizFrame) {
                        vizOverlay.classList.add("hidden");
                        vizFrame.src = "";
                        document.body.style.overflow = "";
                    }
                });
            }
            
            // Close word cloud with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const vizOverlay = document.getElementById('vizOverlay');
                    if (vizOverlay && !vizOverlay.classList.contains('hidden')) {
                        vizOverlay.classList.add("hidden");
                        document.getElementById('vizFrame').src = "";
                        document.body.style.overflow = "";
                    }
                }
            });
        }
        
        setupCompactControls() {
            // Compact filter buttons
            document.getElementById('compact-filter-hate').addEventListener('click', () => {
                this.toggleClassFilter('hate_speech');
            });
            
            document.getElementById('compact-filter-offensive').addEventListener('click', () => {
                this.toggleClassFilter('offensive');
            });
            
            document.getElementById('compact-filter-neither').addEventListener('click', () => {
                this.toggleClassFilter('neither');
            });
            
            // Compact reset
            document.getElementById('compact-reset').addEventListener('click', () => {
                this.resetView();
            });
            
            // Compact lab
            document.getElementById('compact-lab').addEventListener('click', () => {
                this.toggleCounterfactualLab();
            });
            
            // Initialize compact button states
            this.updateCompactFilterButtons();
        }
        
        toggleClassFilter(className) {
            const index = this.selectedClasses.indexOf(className);
            if (index > -1) {
                this.selectedClasses.splice(index, 1);
            } else {
                this.selectedClasses.push(className);
            }
            
            this.filterData();
            this.updateCompactFilterButtons();
            
            // Update full filter buttons
            const fullBtn = document.querySelector(`.filter-btn[data-class="${className}"]`);
            if (fullBtn) {
                fullBtn.classList.toggle('active');
            }
        }
        
        updateCompactFilterButtons() {
            const hateBtn = document.getElementById('compact-filter-hate');
            const offensiveBtn = document.getElementById('compact-filter-offensive');
            const neitherBtn = document.getElementById('compact-filter-neither');
            
            hateBtn.classList.toggle('active', this.selectedClasses.includes('hate_speech'));
            offensiveBtn.classList.toggle('active', this.selectedClasses.includes('offensive'));
            neitherBtn.classList.toggle('active', this.selectedClasses.includes('neither'));
        }
        
        togglePanel() {
            const panel = document.getElementById('controlPanel');
            this.isPanelCompact = !this.isPanelCompact;
            panel.classList.toggle('compact', this.isPanelCompact);
        }
        
        filterData() {
            this.filteredData = this.data.filter(point => 
                this.selectedClasses.includes(point.true_label_name)
            ).slice(0, this.maxRenderPoints);
            this.createVisualization();
        }
        
        showTooltip(data, x, y) {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return;
            
            const isMisclassified = data.true_label_name !== data.predicted_label_name;
            const className = data.true_label_name.replace('_', ' ').toUpperCase();
            const predictedClass = data.predicted_label_name.replace('_', ' ').toUpperCase();
            
            // Calculate percentages for context
            const percentages = {
                hate_speech: ((1430/24783)*100).toFixed(1),
                offensive: ((19190/24783)*100).toFixed(1),
                neither: ((4163/24783)*100).toFixed(1)
            };
            
            tooltip.innerHTML = `
                <div class="tooltip-header">
                    <div style="width: 4px; height: 100%; background: ${
                        data.true_label_name === 'hate_speech' ? 'var(--hate-color)' :
                        data.true_label_name === 'offensive' ? 'var(--offensive-color)' :
                        'var(--neither-color)'
                    }"></div>
                    <div style="flex: 1;">
                        <div class="tooltip-class" style="color: ${
                            data.true_label_name === 'hate_speech' ? 'var(--hate-color)' :
                            data.true_label_name === 'offensive' ? 'var(--offensive-color)' :
                            'var(--neither-color)'
                        }">
                            ${className}
                        </div>
                        <div style="color: ${isMisclassified ? 'var(--misclassified-color)' : 'var(--accent-light)'}; font-size: 0.65rem;">
                            ${isMisclassified ? 'Misclassified as ' + predictedClass : 'Correctly classified'}
                        </div>
                    </div>
                </div>
                <div class="tooltip-text">
                    ${data.original_text.substring(0, 100)}${data.original_text.length > 100 ? '...' : ''}
                </div>
                <div class="tooltip-metrics">
                    <div class="metric">
                        <div class="metric-label">Confidence</div>
                        <div class="metric-value">${(data.confidence * 100).toFixed(1)}%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Ambiguity</div>
                        <div class="metric-value">${data.entropy.toFixed(2)}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Dataset %</div>
                        <div class="metric-value">${percentages[data.true_label_name]}%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Sample</div>
                        <div class="metric-value">#${data.id}</div>
                    </div>
                </div>
            `;
            
            // Position tooltip for mobile (on right side)
            if (this.isMobile) {
                // Mobile positioning - right side
                const rect = tooltip.getBoundingClientRect();
                const right = 10;
                const bottom = 100;
                
                tooltip.style.right = right + 'px';
                tooltip.style.bottom = bottom + 'px';
                tooltip.style.left = 'auto';
                tooltip.style.top = 'auto';
                tooltip.style.transform = 'none';
                tooltip.style.width = 'calc(100% - 2rem)';
                tooltip.style.maxWidth = '280px';
            } else {
                // Desktop positioning - follow cursor
                const rect = tooltip.getBoundingClientRect();
                let left = x + 15;
                let top = y - rect.height / 2;
                
                if (left + rect.width > window.innerWidth) {
                    left = x - rect.width - 15;
                }
                if (top < 10) top = 10;
                if (top + rect.height > window.innerHeight - 10) {
                    top = window.innerHeight - rect.height - 10;
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
                tooltip.style.transform = 'none';
                tooltip.style.width = 'auto';
            }
            
            tooltip.style.display = 'block';
            // Force reflow
            tooltip.offsetHeight;
            tooltip.classList.add('visible');

            // Clear any existing timeout
            if (this.tooltipTimeout) {
                clearTimeout(this.tooltipTimeout);
            }

            // Shorter timeout for faster disappearance
            const timeoutDuration = this.isMobile ? 2000 : 1200;
            this.tooltipTimeout = setTimeout(() => {
                this.hideTooltip();
            }, timeoutDuration);
        }
        
        hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 150);
            }
        }
        
        resetView() {
            const startPosition = this.camera.position.clone();
            const targetPosition = new THREE.Vector3(0, 25, 45); // Zoomed out position
            const duration = 1200;
            const startTime = performance.now();
            
            const animateReset = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                this.camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                this.camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateReset);
                }
            };
            
            requestAnimationFrame(animateReset);
            
            // Show gesture indicator on mobile after reset
            if (this.isMobile) {
                this.showGestureIndicator();
            }
        }
        
        toggleCounterfactualLab() {
            const lab = document.querySelector('.counterfactual-lab');
            lab.style.display = lab.style.display === 'block' ? 'none' : 'block';
        }
        
        analyzeCounterfactual() {
            const text = document.getElementById('text-editor').value;
            if (!text.trim()) return;
            
            const tokens = text.split(/\s+/);
            const tokenViz = document.getElementById('token-viz');
            tokenViz.innerHTML = '';
            
            // Simulate token influence analysis with class-specific colors
            tokens.forEach(token => {
                const span = document.createElement('span');
                span.className = 'token';
                span.textContent = token;
                
                // Random influence for demonstration
                const influence = Math.random();
                if (influence > 0.7) {
                    span.classList.add('hate-influence');
                } else if (influence > 0.4) {
                    span.classList.add('offensive-influence');
                } else {
                    span.classList.add('neither-influence');
                }
                
                tokenViz.appendChild(span);
            });
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            
            const time = Date.now() * 0.001;
            
            // Slow ambient rotation (only when not interacting)
            if (this.ambientRotation && !this.isUserInteracting) {
                const rotationSpeed = 0.04; // Slower rotation
                this.camera.position.x = Math.sin(time * rotationSpeed) * 35;
                this.camera.position.z = Math.cos(time * rotationSpeed) * 35;
                this.camera.lookAt(0, 0, 0);
            }
            
            // Update shader uniforms
            if (this.points && this.points.material && this.points.material.uniforms) {
                this.points.material.uniforms.time.value = time;
            }
            
            this.renderer.render(this.scene, this.camera);
        }
        
        updateStats() {
            // Stats are now displayed in the narrative section
            const visible = this.filteredData.length;
            const hateCount = this.filteredData.filter(p => p.true_label_name === 'hate_speech').length;
            const offensiveCount = this.filteredData.filter(p => p.true_label_name === 'offensive').length;
            const neitherCount = this.filteredData.filter(p => p.true_label_name === 'neither').length;
            
            // Update filter button counts if needed
            document.querySelector('.filter-btn[data-class="hate_speech"] span').textContent = 
                `Hate Speech (${hateCount})`;
            document.querySelector('.filter-btn[data-class="offensive"] span').textContent = 
                `Offensive (${offensiveCount})`;
            document.querySelector('.filter-btn[data-class="neither"] span').textContent = 
                `Neither (${neitherCount})`;
        }
        
        showError(message) {
            console.error('Error:', message);
            
            const errorDiv = document.getElementById('error-display');
            const errorMsg = document.getElementById('error-message');
            
            if (errorDiv && errorMsg) {
                errorMsg.textContent = message || 'Unknown error occurred';
                errorDiv.style.display = 'block';
                document.getElementById('loading-screen').style.display = 'none';
            }
        }
        
        showGestureIndicator() {
            if (!this.isMobile) return;
            
            const indicator = document.getElementById('gestureIndicator');
            indicator.classList.add('visible');
            
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 3000);
        }
    }
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', () => {
        if (typeof THREE === 'undefined') {
            document.getElementById('error-display').style.display = 'block';
            document.getElementById('error-message').textContent = 
                'Three.js library failed to load. Please refresh the page.';
            return;
        }
        
        try {
            window.visualization = new HateSpeechVisualization();
        } catch (error) {
            console.error('Failed to initialize visualization:', error);
            const errorDiv = document.getElementById('error-display');
            const errorMsg = document.getElementById('error-message');
            if (errorDiv && errorMsg) {
                errorMsg.textContent = error.message || 'Failed to initialize visualization';
                errorDiv.style.display = 'block';
            }
        }
    });
    </script>
</body>
</html>